/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeInappRnSdkFeatureOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
struct NativeInappRnSdkFeatureOptions {
  P0 cookiePersist;
  P1 singleReclaimRequest;
  P2 idleTimeThresholdForManualVerificationTrigger;
  P3 sessionTimeoutForManualVerificationTrigger;
  P4 attestorBrowserRpcUrl;
  P5 isAIFlowEnabled;
  bool operator==(const NativeInappRnSdkFeatureOptions &other) const {
    return cookiePersist == other.cookiePersist && singleReclaimRequest == other.singleReclaimRequest && idleTimeThresholdForManualVerificationTrigger == other.idleTimeThresholdForManualVerificationTrigger && sessionTimeoutForManualVerificationTrigger == other.sessionTimeoutForManualVerificationTrigger && attestorBrowserRpcUrl == other.attestorBrowserRpcUrl && isAIFlowEnabled == other.isAIFlowEnabled;
  }
};

template <typename T>
struct NativeInappRnSdkFeatureOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.cookiePersist)>(rt, value.getProperty(rt, "cookiePersist"), jsInvoker),
      bridging::fromJs<decltype(types.singleReclaimRequest)>(rt, value.getProperty(rt, "singleReclaimRequest"), jsInvoker),
      bridging::fromJs<decltype(types.idleTimeThresholdForManualVerificationTrigger)>(rt, value.getProperty(rt, "idleTimeThresholdForManualVerificationTrigger"), jsInvoker),
      bridging::fromJs<decltype(types.sessionTimeoutForManualVerificationTrigger)>(rt, value.getProperty(rt, "sessionTimeoutForManualVerificationTrigger"), jsInvoker),
      bridging::fromJs<decltype(types.attestorBrowserRpcUrl)>(rt, value.getProperty(rt, "attestorBrowserRpcUrl"), jsInvoker),
      bridging::fromJs<decltype(types.isAIFlowEnabled)>(rt, value.getProperty(rt, "isAIFlowEnabled"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<bool> cookiePersistToJs(jsi::Runtime &rt, decltype(types.cookiePersist) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> singleReclaimRequestToJs(jsi::Runtime &rt, decltype(types.singleReclaimRequest) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> idleTimeThresholdForManualVerificationTriggerToJs(jsi::Runtime &rt, decltype(types.idleTimeThresholdForManualVerificationTrigger) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<double> sessionTimeoutForManualVerificationTriggerToJs(jsi::Runtime &rt, decltype(types.sessionTimeoutForManualVerificationTrigger) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> attestorBrowserRpcUrlToJs(jsi::Runtime &rt, decltype(types.attestorBrowserRpcUrl) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<bool> isAIFlowEnabledToJs(jsi::Runtime &rt, decltype(types.isAIFlowEnabled) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.cookiePersist) {
      result.setProperty(rt, "cookiePersist", bridging::toJs(rt, value.cookiePersist.value(), jsInvoker));
    }
    if (value.singleReclaimRequest) {
      result.setProperty(rt, "singleReclaimRequest", bridging::toJs(rt, value.singleReclaimRequest.value(), jsInvoker));
    }
    if (value.idleTimeThresholdForManualVerificationTrigger) {
      result.setProperty(rt, "idleTimeThresholdForManualVerificationTrigger", bridging::toJs(rt, value.idleTimeThresholdForManualVerificationTrigger.value(), jsInvoker));
    }
    if (value.sessionTimeoutForManualVerificationTrigger) {
      result.setProperty(rt, "sessionTimeoutForManualVerificationTrigger", bridging::toJs(rt, value.sessionTimeoutForManualVerificationTrigger.value(), jsInvoker));
    }
    if (value.attestorBrowserRpcUrl) {
      result.setProperty(rt, "attestorBrowserRpcUrl", bridging::toJs(rt, value.attestorBrowserRpcUrl.value(), jsInvoker));
    }
    if (value.isAIFlowEnabled) {
      result.setProperty(rt, "isAIFlowEnabled", bridging::toJs(rt, value.isAIFlowEnabled.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeInappRnSdkLogConsumer

template <typename P0, typename P1, typename P2>
struct NativeInappRnSdkLogConsumer {
  P0 enableLogHandler;
  P1 canSdkCollectTelemetry;
  P2 canSdkPrintLogs;
  bool operator==(const NativeInappRnSdkLogConsumer &other) const {
    return enableLogHandler == other.enableLogHandler && canSdkCollectTelemetry == other.canSdkCollectTelemetry && canSdkPrintLogs == other.canSdkPrintLogs;
  }
};

template <typename T>
struct NativeInappRnSdkLogConsumerBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.enableLogHandler)>(rt, value.getProperty(rt, "enableLogHandler"), jsInvoker),
      bridging::fromJs<decltype(types.canSdkCollectTelemetry)>(rt, value.getProperty(rt, "canSdkCollectTelemetry"), jsInvoker),
      bridging::fromJs<decltype(types.canSdkPrintLogs)>(rt, value.getProperty(rt, "canSdkPrintLogs"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool enableLogHandlerToJs(jsi::Runtime &rt, decltype(types.enableLogHandler) value) {
    return bridging::toJs(rt, value);
  }

  static bool canSdkCollectTelemetryToJs(jsi::Runtime &rt, decltype(types.canSdkCollectTelemetry) value) {
    return bridging::toJs(rt, value);
  }

  static bool canSdkPrintLogsToJs(jsi::Runtime &rt, decltype(types.canSdkPrintLogs) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "enableLogHandler", bridging::toJs(rt, value.enableLogHandler, jsInvoker));
    if (value.canSdkCollectTelemetry) {
      result.setProperty(rt, "canSdkCollectTelemetry", bridging::toJs(rt, value.canSdkCollectTelemetry.value(), jsInvoker));
    }
    if (value.canSdkPrintLogs) {
      result.setProperty(rt, "canSdkPrintLogs", bridging::toJs(rt, value.canSdkPrintLogs.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeInappRnSdkOverrides

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
struct NativeInappRnSdkOverrides {
  P0 provider;
  P1 featureOptions;
  P2 logConsumer;
  P3 sessionManagement;
  P4 appInfo;
  P5 capabilityAccessToken;
  bool operator==(const NativeInappRnSdkOverrides &other) const {
    return provider == other.provider && featureOptions == other.featureOptions && logConsumer == other.logConsumer && sessionManagement == other.sessionManagement && appInfo == other.appInfo && capabilityAccessToken == other.capabilityAccessToken;
  }
};

template <typename T>
struct NativeInappRnSdkOverridesBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.provider)>(rt, value.getProperty(rt, "provider"), jsInvoker),
      bridging::fromJs<decltype(types.featureOptions)>(rt, value.getProperty(rt, "featureOptions"), jsInvoker),
      bridging::fromJs<decltype(types.logConsumer)>(rt, value.getProperty(rt, "logConsumer"), jsInvoker),
      bridging::fromJs<decltype(types.sessionManagement)>(rt, value.getProperty(rt, "sessionManagement"), jsInvoker),
      bridging::fromJs<decltype(types.appInfo)>(rt, value.getProperty(rt, "appInfo"), jsInvoker),
      bridging::fromJs<decltype(types.capabilityAccessToken)>(rt, value.getProperty(rt, "capabilityAccessToken"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::Object> providerToJs(jsi::Runtime &rt, decltype(types.provider) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Object> featureOptionsToJs(jsi::Runtime &rt, decltype(types.featureOptions) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Object> logConsumerToJs(jsi::Runtime &rt, decltype(types.logConsumer) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Object> sessionManagementToJs(jsi::Runtime &rt, decltype(types.sessionManagement) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Object> appInfoToJs(jsi::Runtime &rt, decltype(types.appInfo) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> capabilityAccessTokenToJs(jsi::Runtime &rt, decltype(types.capabilityAccessToken) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.provider) {
      result.setProperty(rt, "provider", bridging::toJs(rt, value.provider.value(), jsInvoker));
    }
    if (value.featureOptions) {
      result.setProperty(rt, "featureOptions", bridging::toJs(rt, value.featureOptions.value(), jsInvoker));
    }
    if (value.logConsumer) {
      result.setProperty(rt, "logConsumer", bridging::toJs(rt, value.logConsumer.value(), jsInvoker));
    }
    if (value.sessionManagement) {
      result.setProperty(rt, "sessionManagement", bridging::toJs(rt, value.sessionManagement.value(), jsInvoker));
    }
    if (value.appInfo) {
      result.setProperty(rt, "appInfo", bridging::toJs(rt, value.appInfo.value(), jsInvoker));
    }
    if (value.capabilityAccessToken) {
      result.setProperty(rt, "capabilityAccessToken", bridging::toJs(rt, value.capabilityAccessToken.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeInappRnSdkProviderInformation

template <typename P0, typename P1, typename P2>
struct NativeInappRnSdkProviderInformation {
  P0 url;
  P1 jsonString;
  P2 canFetchProviderInformationFromHost;
  bool operator==(const NativeInappRnSdkProviderInformation &other) const {
    return url == other.url && jsonString == other.jsonString && canFetchProviderInformationFromHost == other.canFetchProviderInformationFromHost;
  }
};

template <typename T>
struct NativeInappRnSdkProviderInformationBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.url)>(rt, value.getProperty(rt, "url"), jsInvoker),
      bridging::fromJs<decltype(types.jsonString)>(rt, value.getProperty(rt, "jsonString"), jsInvoker),
      bridging::fromJs<decltype(types.canFetchProviderInformationFromHost)>(rt, value.getProperty(rt, "canFetchProviderInformationFromHost"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String urlToJs(jsi::Runtime &rt, decltype(types.url) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String jsonStringToJs(jsi::Runtime &rt, decltype(types.jsonString) value) {
    return bridging::toJs(rt, value);
  }

  static bool canFetchProviderInformationFromHostToJs(jsi::Runtime &rt, decltype(types.canFetchProviderInformationFromHost) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.url) {
      result.setProperty(rt, "url", bridging::toJs(rt, value.url.value(), jsInvoker));
    }
    if (value.jsonString) {
      result.setProperty(rt, "jsonString", bridging::toJs(rt, value.jsonString.value(), jsInvoker));
    }
    result.setProperty(rt, "canFetchProviderInformationFromHost", bridging::toJs(rt, value.canFetchProviderInformationFromHost, jsInvoker));
    return result;
  }
};



#pragma mark - NativeInappRnSdkProviderInformationRequest

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
struct NativeInappRnSdkProviderInformationRequest {
  P0 appId;
  P1 providerId;
  P2 sessionId;
  P3 signature;
  P4 timestamp;
  P5 replyId;
  bool operator==(const NativeInappRnSdkProviderInformationRequest &other) const {
    return appId == other.appId && providerId == other.providerId && sessionId == other.sessionId && signature == other.signature && timestamp == other.timestamp && replyId == other.replyId;
  }
};

template <typename T>
struct NativeInappRnSdkProviderInformationRequestBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.appId)>(rt, value.getProperty(rt, "appId"), jsInvoker),
      bridging::fromJs<decltype(types.providerId)>(rt, value.getProperty(rt, "providerId"), jsInvoker),
      bridging::fromJs<decltype(types.sessionId)>(rt, value.getProperty(rt, "sessionId"), jsInvoker),
      bridging::fromJs<decltype(types.signature)>(rt, value.getProperty(rt, "signature"), jsInvoker),
      bridging::fromJs<decltype(types.timestamp)>(rt, value.getProperty(rt, "timestamp"), jsInvoker),
      bridging::fromJs<decltype(types.replyId)>(rt, value.getProperty(rt, "replyId"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String appIdToJs(jsi::Runtime &rt, decltype(types.appId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String providerIdToJs(jsi::Runtime &rt, decltype(types.providerId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String sessionIdToJs(jsi::Runtime &rt, decltype(types.sessionId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String signatureToJs(jsi::Runtime &rt, decltype(types.signature) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String timestampToJs(jsi::Runtime &rt, decltype(types.timestamp) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String replyIdToJs(jsi::Runtime &rt, decltype(types.replyId) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "appId", bridging::toJs(rt, value.appId, jsInvoker));
    result.setProperty(rt, "providerId", bridging::toJs(rt, value.providerId, jsInvoker));
    result.setProperty(rt, "sessionId", bridging::toJs(rt, value.sessionId, jsInvoker));
    result.setProperty(rt, "signature", bridging::toJs(rt, value.signature, jsInvoker));
    result.setProperty(rt, "timestamp", bridging::toJs(rt, value.timestamp, jsInvoker));
    result.setProperty(rt, "replyId", bridging::toJs(rt, value.replyId, jsInvoker));
    return result;
  }
};



#pragma mark - NativeInappRnSdkReclaimAppInfo

template <typename P0, typename P1, typename P2>
struct NativeInappRnSdkReclaimAppInfo {
  P0 appName;
  P1 appImageUrl;
  P2 isRecurring;
  bool operator==(const NativeInappRnSdkReclaimAppInfo &other) const {
    return appName == other.appName && appImageUrl == other.appImageUrl && isRecurring == other.isRecurring;
  }
};

template <typename T>
struct NativeInappRnSdkReclaimAppInfoBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.appName)>(rt, value.getProperty(rt, "appName"), jsInvoker),
      bridging::fromJs<decltype(types.appImageUrl)>(rt, value.getProperty(rt, "appImageUrl"), jsInvoker),
      bridging::fromJs<decltype(types.isRecurring)>(rt, value.getProperty(rt, "isRecurring"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String appNameToJs(jsi::Runtime &rt, decltype(types.appName) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String appImageUrlToJs(jsi::Runtime &rt, decltype(types.appImageUrl) value) {
    return bridging::toJs(rt, value);
  }

  static bool isRecurringToJs(jsi::Runtime &rt, decltype(types.isRecurring) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "appName", bridging::toJs(rt, value.appName, jsInvoker));
    result.setProperty(rt, "appImageUrl", bridging::toJs(rt, value.appImageUrl, jsInvoker));
    if (value.isRecurring) {
      result.setProperty(rt, "isRecurring", bridging::toJs(rt, value.isRecurring.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeInappRnSdkReclaimAttestorAuthRequest

template <typename P0, typename P1>
struct NativeInappRnSdkReclaimAttestorAuthRequest {
  P0 reclaimHttpProviderJsonString;
  P1 replyId;
  bool operator==(const NativeInappRnSdkReclaimAttestorAuthRequest &other) const {
    return reclaimHttpProviderJsonString == other.reclaimHttpProviderJsonString && replyId == other.replyId;
  }
};

template <typename T>
struct NativeInappRnSdkReclaimAttestorAuthRequestBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.reclaimHttpProviderJsonString)>(rt, value.getProperty(rt, "reclaimHttpProviderJsonString"), jsInvoker),
      bridging::fromJs<decltype(types.replyId)>(rt, value.getProperty(rt, "replyId"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String reclaimHttpProviderJsonStringToJs(jsi::Runtime &rt, decltype(types.reclaimHttpProviderJsonString) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String replyIdToJs(jsi::Runtime &rt, decltype(types.replyId) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "reclaimHttpProviderJsonString", bridging::toJs(rt, value.reclaimHttpProviderJsonString, jsInvoker));
    result.setProperty(rt, "replyId", bridging::toJs(rt, value.replyId, jsInvoker));
    return result;
  }
};



#pragma mark - NativeInappRnSdkReclaimSessionIdentityUpdate

template <typename P0, typename P1, typename P2>
struct NativeInappRnSdkReclaimSessionIdentityUpdate {
  P0 appId;
  P1 providerId;
  P2 sessionId;
  bool operator==(const NativeInappRnSdkReclaimSessionIdentityUpdate &other) const {
    return appId == other.appId && providerId == other.providerId && sessionId == other.sessionId;
  }
};

template <typename T>
struct NativeInappRnSdkReclaimSessionIdentityUpdateBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.appId)>(rt, value.getProperty(rt, "appId"), jsInvoker),
      bridging::fromJs<decltype(types.providerId)>(rt, value.getProperty(rt, "providerId"), jsInvoker),
      bridging::fromJs<decltype(types.sessionId)>(rt, value.getProperty(rt, "sessionId"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String appIdToJs(jsi::Runtime &rt, decltype(types.appId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String providerIdToJs(jsi::Runtime &rt, decltype(types.providerId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String sessionIdToJs(jsi::Runtime &rt, decltype(types.sessionId) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "appId", bridging::toJs(rt, value.appId, jsInvoker));
    result.setProperty(rt, "providerId", bridging::toJs(rt, value.providerId, jsInvoker));
    result.setProperty(rt, "sessionId", bridging::toJs(rt, value.sessionId, jsInvoker));
    return result;
  }
};



#pragma mark - NativeInappRnSdkRequest

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct NativeInappRnSdkRequest {
  P0 appId;
  P1 secret;
  P2 providerId;
  P3 session;
  P4 contextString;
  P5 parameters;
  P6 acceptAiProviders;
  P7 webhookUrl;
  bool operator==(const NativeInappRnSdkRequest &other) const {
    return appId == other.appId && secret == other.secret && providerId == other.providerId && session == other.session && contextString == other.contextString && parameters == other.parameters && acceptAiProviders == other.acceptAiProviders && webhookUrl == other.webhookUrl;
  }
};

template <typename T>
struct NativeInappRnSdkRequestBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.appId)>(rt, value.getProperty(rt, "appId"), jsInvoker),
      bridging::fromJs<decltype(types.secret)>(rt, value.getProperty(rt, "secret"), jsInvoker),
      bridging::fromJs<decltype(types.providerId)>(rt, value.getProperty(rt, "providerId"), jsInvoker),
      bridging::fromJs<decltype(types.session)>(rt, value.getProperty(rt, "session"), jsInvoker),
      bridging::fromJs<decltype(types.contextString)>(rt, value.getProperty(rt, "contextString"), jsInvoker),
      bridging::fromJs<decltype(types.parameters)>(rt, value.getProperty(rt, "parameters"), jsInvoker),
      bridging::fromJs<decltype(types.acceptAiProviders)>(rt, value.getProperty(rt, "acceptAiProviders"), jsInvoker),
      bridging::fromJs<decltype(types.webhookUrl)>(rt, value.getProperty(rt, "webhookUrl"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String appIdToJs(jsi::Runtime &rt, decltype(types.appId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String secretToJs(jsi::Runtime &rt, decltype(types.secret) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String providerIdToJs(jsi::Runtime &rt, decltype(types.providerId) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::Object> sessionToJs(jsi::Runtime &rt, decltype(types.session) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String contextStringToJs(jsi::Runtime &rt, decltype(types.contextString) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object parametersToJs(jsi::Runtime &rt, decltype(types.parameters) value) {
    return bridging::toJs(rt, value);
  }

  static bool acceptAiProvidersToJs(jsi::Runtime &rt, decltype(types.acceptAiProviders) value) {
    return bridging::toJs(rt, value);
  }

  static std::optional<jsi::String> webhookUrlToJs(jsi::Runtime &rt, decltype(types.webhookUrl) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "appId", bridging::toJs(rt, value.appId, jsInvoker));
    result.setProperty(rt, "secret", bridging::toJs(rt, value.secret, jsInvoker));
    result.setProperty(rt, "providerId", bridging::toJs(rt, value.providerId, jsInvoker));
    if (value.session) {
      result.setProperty(rt, "session", bridging::toJs(rt, value.session.value(), jsInvoker));
    }
    if (value.contextString) {
      result.setProperty(rt, "contextString", bridging::toJs(rt, value.contextString.value(), jsInvoker));
    }
    if (value.parameters) {
      result.setProperty(rt, "parameters", bridging::toJs(rt, value.parameters.value(), jsInvoker));
    }
    if (value.acceptAiProviders) {
      result.setProperty(rt, "acceptAiProviders", bridging::toJs(rt, value.acceptAiProviders.value(), jsInvoker));
    }
    if (value.webhookUrl) {
      result.setProperty(rt, "webhookUrl", bridging::toJs(rt, value.webhookUrl.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeInappRnSdkResponse

template <typename P0, typename P1, typename P2>
struct NativeInappRnSdkResponse {
  P0 sessionId;
  P1 didSubmitManualVerification;
  P2 proofs;
  bool operator==(const NativeInappRnSdkResponse &other) const {
    return sessionId == other.sessionId && didSubmitManualVerification == other.didSubmitManualVerification && proofs == other.proofs;
  }
};

template <typename T>
struct NativeInappRnSdkResponseBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.sessionId)>(rt, value.getProperty(rt, "sessionId"), jsInvoker),
      bridging::fromJs<decltype(types.didSubmitManualVerification)>(rt, value.getProperty(rt, "didSubmitManualVerification"), jsInvoker),
      bridging::fromJs<decltype(types.proofs)>(rt, value.getProperty(rt, "proofs"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String sessionIdToJs(jsi::Runtime &rt, decltype(types.sessionId) value) {
    return bridging::toJs(rt, value);
  }

  static bool didSubmitManualVerificationToJs(jsi::Runtime &rt, decltype(types.didSubmitManualVerification) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array proofsToJs(jsi::Runtime &rt, decltype(types.proofs) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "sessionId", bridging::toJs(rt, value.sessionId, jsInvoker));
    result.setProperty(rt, "didSubmitManualVerification", bridging::toJs(rt, value.didSubmitManualVerification, jsInvoker));
    result.setProperty(rt, "proofs", bridging::toJs(rt, value.proofs, jsInvoker));
    return result;
  }
};



#pragma mark - NativeInappRnSdkSessionCreateRequestEvent

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeInappRnSdkSessionCreateRequestEvent {
  P0 appId;
  P1 providerId;
  P2 timestamp;
  P3 signature;
  P4 replyId;
  bool operator==(const NativeInappRnSdkSessionCreateRequestEvent &other) const {
    return appId == other.appId && providerId == other.providerId && timestamp == other.timestamp && signature == other.signature && replyId == other.replyId;
  }
};

template <typename T>
struct NativeInappRnSdkSessionCreateRequestEventBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.appId)>(rt, value.getProperty(rt, "appId"), jsInvoker),
      bridging::fromJs<decltype(types.providerId)>(rt, value.getProperty(rt, "providerId"), jsInvoker),
      bridging::fromJs<decltype(types.timestamp)>(rt, value.getProperty(rt, "timestamp"), jsInvoker),
      bridging::fromJs<decltype(types.signature)>(rt, value.getProperty(rt, "signature"), jsInvoker),
      bridging::fromJs<decltype(types.replyId)>(rt, value.getProperty(rt, "replyId"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String appIdToJs(jsi::Runtime &rt, decltype(types.appId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String providerIdToJs(jsi::Runtime &rt, decltype(types.providerId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String timestampToJs(jsi::Runtime &rt, decltype(types.timestamp) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String signatureToJs(jsi::Runtime &rt, decltype(types.signature) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String replyIdToJs(jsi::Runtime &rt, decltype(types.replyId) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "appId", bridging::toJs(rt, value.appId, jsInvoker));
    result.setProperty(rt, "providerId", bridging::toJs(rt, value.providerId, jsInvoker));
    result.setProperty(rt, "timestamp", bridging::toJs(rt, value.timestamp, jsInvoker));
    result.setProperty(rt, "signature", bridging::toJs(rt, value.signature, jsInvoker));
    result.setProperty(rt, "replyId", bridging::toJs(rt, value.replyId, jsInvoker));
    return result;
  }
};



#pragma mark - NativeInappRnSdkSessionInformation

template <typename P0, typename P1, typename P2>
struct NativeInappRnSdkSessionInformation {
  P0 timestamp;
  P1 sessionId;
  P2 signature;
  bool operator==(const NativeInappRnSdkSessionInformation &other) const {
    return timestamp == other.timestamp && sessionId == other.sessionId && signature == other.signature;
  }
};

template <typename T>
struct NativeInappRnSdkSessionInformationBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.timestamp)>(rt, value.getProperty(rt, "timestamp"), jsInvoker),
      bridging::fromJs<decltype(types.sessionId)>(rt, value.getProperty(rt, "sessionId"), jsInvoker),
      bridging::fromJs<decltype(types.signature)>(rt, value.getProperty(rt, "signature"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String timestampToJs(jsi::Runtime &rt, decltype(types.timestamp) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String sessionIdToJs(jsi::Runtime &rt, decltype(types.sessionId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String signatureToJs(jsi::Runtime &rt, decltype(types.signature) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "timestamp", bridging::toJs(rt, value.timestamp, jsInvoker));
    result.setProperty(rt, "sessionId", bridging::toJs(rt, value.sessionId, jsInvoker));
    result.setProperty(rt, "signature", bridging::toJs(rt, value.signature, jsInvoker));
    return result;
  }
};



#pragma mark - NativeInappRnSdkSessionLogEvent

template <typename P0, typename P1, typename P2, typename P3>
struct NativeInappRnSdkSessionLogEvent {
  P0 appId;
  P1 providerId;
  P2 sessionId;
  P3 logType;
  bool operator==(const NativeInappRnSdkSessionLogEvent &other) const {
    return appId == other.appId && providerId == other.providerId && sessionId == other.sessionId && logType == other.logType;
  }
};

template <typename T>
struct NativeInappRnSdkSessionLogEventBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.appId)>(rt, value.getProperty(rt, "appId"), jsInvoker),
      bridging::fromJs<decltype(types.providerId)>(rt, value.getProperty(rt, "providerId"), jsInvoker),
      bridging::fromJs<decltype(types.sessionId)>(rt, value.getProperty(rt, "sessionId"), jsInvoker),
      bridging::fromJs<decltype(types.logType)>(rt, value.getProperty(rt, "logType"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String appIdToJs(jsi::Runtime &rt, decltype(types.appId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String providerIdToJs(jsi::Runtime &rt, decltype(types.providerId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String sessionIdToJs(jsi::Runtime &rt, decltype(types.sessionId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String logTypeToJs(jsi::Runtime &rt, decltype(types.logType) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "appId", bridging::toJs(rt, value.appId, jsInvoker));
    result.setProperty(rt, "providerId", bridging::toJs(rt, value.providerId, jsInvoker));
    result.setProperty(rt, "sessionId", bridging::toJs(rt, value.sessionId, jsInvoker));
    result.setProperty(rt, "logType", bridging::toJs(rt, value.logType, jsInvoker));
    return result;
  }
};



#pragma mark - NativeInappRnSdkSessionManagement

template <typename P0>
struct NativeInappRnSdkSessionManagement {
  P0 enableSdkSessionManagement;
  bool operator==(const NativeInappRnSdkSessionManagement &other) const {
    return enableSdkSessionManagement == other.enableSdkSessionManagement;
  }
};

template <typename T>
struct NativeInappRnSdkSessionManagementBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.enableSdkSessionManagement)>(rt, value.getProperty(rt, "enableSdkSessionManagement"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool enableSdkSessionManagementToJs(jsi::Runtime &rt, decltype(types.enableSdkSessionManagement) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.enableSdkSessionManagement) {
      result.setProperty(rt, "enableSdkSessionManagement", bridging::toJs(rt, value.enableSdkSessionManagement.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeInappRnSdkSessionUpdateRequestEvent

template <typename P0, typename P1, typename P2>
struct NativeInappRnSdkSessionUpdateRequestEvent {
  P0 sessionId;
  P1 status;
  P2 replyId;
  bool operator==(const NativeInappRnSdkSessionUpdateRequestEvent &other) const {
    return sessionId == other.sessionId && status == other.status && replyId == other.replyId;
  }
};

template <typename T>
struct NativeInappRnSdkSessionUpdateRequestEventBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.sessionId)>(rt, value.getProperty(rt, "sessionId"), jsInvoker),
      bridging::fromJs<decltype(types.status)>(rt, value.getProperty(rt, "status"), jsInvoker),
      bridging::fromJs<decltype(types.replyId)>(rt, value.getProperty(rt, "replyId"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String sessionIdToJs(jsi::Runtime &rt, decltype(types.sessionId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String statusToJs(jsi::Runtime &rt, decltype(types.status) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String replyIdToJs(jsi::Runtime &rt, decltype(types.replyId) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "sessionId", bridging::toJs(rt, value.sessionId, jsInvoker));
    result.setProperty(rt, "status", bridging::toJs(rt, value.status, jsInvoker));
    result.setProperty(rt, "replyId", bridging::toJs(rt, value.replyId, jsInvoker));
    return result;
  }
};



#pragma mark - NativeInappRnSdkVerificationOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeInappRnSdkVerificationOptions {
  P0 canDeleteCookiesBeforeVerificationStarts;
  P1 canUseAttestorAuthenticationRequest;
  P2 claimCreationType;
  P3 canAutoSubmit;
  P4 isCloseButtonVisible;
  bool operator==(const NativeInappRnSdkVerificationOptions &other) const {
    return canDeleteCookiesBeforeVerificationStarts == other.canDeleteCookiesBeforeVerificationStarts && canUseAttestorAuthenticationRequest == other.canUseAttestorAuthenticationRequest && claimCreationType == other.claimCreationType && canAutoSubmit == other.canAutoSubmit && isCloseButtonVisible == other.isCloseButtonVisible;
  }
};

template <typename T>
struct NativeInappRnSdkVerificationOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.canDeleteCookiesBeforeVerificationStarts)>(rt, value.getProperty(rt, "canDeleteCookiesBeforeVerificationStarts"), jsInvoker),
      bridging::fromJs<decltype(types.canUseAttestorAuthenticationRequest)>(rt, value.getProperty(rt, "canUseAttestorAuthenticationRequest"), jsInvoker),
      bridging::fromJs<decltype(types.claimCreationType)>(rt, value.getProperty(rt, "claimCreationType"), jsInvoker),
      bridging::fromJs<decltype(types.canAutoSubmit)>(rt, value.getProperty(rt, "canAutoSubmit"), jsInvoker),
      bridging::fromJs<decltype(types.isCloseButtonVisible)>(rt, value.getProperty(rt, "isCloseButtonVisible"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool canDeleteCookiesBeforeVerificationStartsToJs(jsi::Runtime &rt, decltype(types.canDeleteCookiesBeforeVerificationStarts) value) {
    return bridging::toJs(rt, value);
  }

  static bool canUseAttestorAuthenticationRequestToJs(jsi::Runtime &rt, decltype(types.canUseAttestorAuthenticationRequest) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String claimCreationTypeToJs(jsi::Runtime &rt, decltype(types.claimCreationType) value) {
    return bridging::toJs(rt, value);
  }

  static bool canAutoSubmitToJs(jsi::Runtime &rt, decltype(types.canAutoSubmit) value) {
    return bridging::toJs(rt, value);
  }

  static bool isCloseButtonVisibleToJs(jsi::Runtime &rt, decltype(types.isCloseButtonVisible) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "canDeleteCookiesBeforeVerificationStarts", bridging::toJs(rt, value.canDeleteCookiesBeforeVerificationStarts, jsInvoker));
    result.setProperty(rt, "canUseAttestorAuthenticationRequest", bridging::toJs(rt, value.canUseAttestorAuthenticationRequest, jsInvoker));
    result.setProperty(rt, "claimCreationType", bridging::toJs(rt, value.claimCreationType, jsInvoker));
    result.setProperty(rt, "canAutoSubmit", bridging::toJs(rt, value.canAutoSubmit, jsInvoker));
    result.setProperty(rt, "isCloseButtonVisible", bridging::toJs(rt, value.isCloseButtonVisible, jsInvoker));
    return result;
  }
};



#pragma mark - NativeInappRnSdkVerificationOptionsOptional

template <typename P0>
struct NativeInappRnSdkVerificationOptionsOptional {
  P0 options;
  bool operator==(const NativeInappRnSdkVerificationOptionsOptional &other) const {
    return options == other.options;
  }
};

template <typename T>
struct NativeInappRnSdkVerificationOptionsOptionalBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.options)>(rt, value.getProperty(rt, "options"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static std::optional<jsi::Object> optionsToJs(jsi::Runtime &rt, decltype(types.options) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.options) {
      result.setProperty(rt, "options", bridging::toJs(rt, value.options.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeInappRnSdkCxxSpecJSI : public TurboModule {
protected:
  NativeInappRnSdkCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value startVerification(jsi::Runtime &rt, jsi::Object request) = 0;
  virtual jsi::Value startVerificationFromUrl(jsi::Runtime &rt, jsi::String requestUrl) = 0;
  virtual jsi::Value setOverrides(jsi::Runtime &rt, jsi::Object overrides) = 0;
  virtual jsi::Value clearAllOverrides(jsi::Runtime &rt) = 0;
  virtual jsi::Value setVerificationOptions(jsi::Runtime &rt, jsi::Object args) = 0;
  virtual void reply(jsi::Runtime &rt, jsi::String replyId, bool reply) = 0;
  virtual void replyWithString(jsi::Runtime &rt, jsi::String replyId, jsi::String value) = 0;
  virtual jsi::Value ping(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeInappRnSdkCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "InappRnSdk";

protected:
  NativeInappRnSdkCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeInappRnSdkCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

  template <typename OnLogsType> void emitOnLogs(OnLogsType value) {
    static_assert(bridging::supportsFromJs<OnLogsType, jsi::String>, "value cannnot be converted to jsi::String");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onLogs"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnSessionLogsType> void emitOnSessionLogs(OnSessionLogsType value) {
    static_assert(bridging::supportsFromJs<OnSessionLogsType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onSessionLogs"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnSessionCreateRequestType> void emitOnSessionCreateRequest(OnSessionCreateRequestType value) {
    static_assert(bridging::supportsFromJs<OnSessionCreateRequestType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onSessionCreateRequest"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnSessionUpdateRequestType> void emitOnSessionUpdateRequest(OnSessionUpdateRequestType value) {
    static_assert(bridging::supportsFromJs<OnSessionUpdateRequestType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onSessionUpdateRequest"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnProviderInformationRequestType> void emitOnProviderInformationRequest(OnProviderInformationRequestType value) {
    static_assert(bridging::supportsFromJs<OnProviderInformationRequestType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onProviderInformationRequest"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnReclaimAttestorAuthRequestType> void emitOnReclaimAttestorAuthRequest(OnReclaimAttestorAuthRequestType value) {
    static_assert(bridging::supportsFromJs<OnReclaimAttestorAuthRequestType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onReclaimAttestorAuthRequest"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

  template <typename OnSessionIdentityUpdateType> void emitOnSessionIdentityUpdate(OnSessionIdentityUpdateType value) {
    static_assert(bridging::supportsFromJs<OnSessionIdentityUpdateType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onSessionIdentityUpdate"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

private:
  class Delegate : public NativeInappRnSdkCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeInappRnSdkCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
      eventEmitterMap_["onLogs"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onSessionLogs"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onSessionCreateRequest"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onSessionUpdateRequest"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onProviderInformationRequest"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onReclaimAttestorAuthRequest"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
      eventEmitterMap_["onSessionIdentityUpdate"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
    }

    jsi::Value startVerification(jsi::Runtime &rt, jsi::Object request) override {
      static_assert(
          bridging::getParameterCount(&T::startVerification) == 2,
          "Expected startVerification(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::startVerification, jsInvoker_, instance_, std::move(request));
    }
    jsi::Value startVerificationFromUrl(jsi::Runtime &rt, jsi::String requestUrl) override {
      static_assert(
          bridging::getParameterCount(&T::startVerificationFromUrl) == 2,
          "Expected startVerificationFromUrl(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::startVerificationFromUrl, jsInvoker_, instance_, std::move(requestUrl));
    }
    jsi::Value setOverrides(jsi::Runtime &rt, jsi::Object overrides) override {
      static_assert(
          bridging::getParameterCount(&T::setOverrides) == 2,
          "Expected setOverrides(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setOverrides, jsInvoker_, instance_, std::move(overrides));
    }
    jsi::Value clearAllOverrides(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::clearAllOverrides) == 1,
          "Expected clearAllOverrides(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::clearAllOverrides, jsInvoker_, instance_);
    }
    jsi::Value setVerificationOptions(jsi::Runtime &rt, jsi::Object args) override {
      static_assert(
          bridging::getParameterCount(&T::setVerificationOptions) == 2,
          "Expected setVerificationOptions(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setVerificationOptions, jsInvoker_, instance_, std::move(args));
    }
    void reply(jsi::Runtime &rt, jsi::String replyId, bool reply) override {
      static_assert(
          bridging::getParameterCount(&T::reply) == 3,
          "Expected reply(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::reply, jsInvoker_, instance_, std::move(replyId), std::move(reply));
    }
    void replyWithString(jsi::Runtime &rt, jsi::String replyId, jsi::String value) override {
      static_assert(
          bridging::getParameterCount(&T::replyWithString) == 3,
          "Expected replyWithString(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::replyWithString, jsInvoker_, instance_, std::move(replyId), std::move(value));
    }
    jsi::Value ping(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::ping) == 1,
          "Expected ping(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::ping, jsInvoker_, instance_);
    }

  private:
    friend class NativeInappRnSdkCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
